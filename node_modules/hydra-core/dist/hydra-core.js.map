{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "hydra-core.js",
    "lib/core.js",
    "lib/http-client.js",
    "lib/model.js",
    "lib/utils.js",
    "lib/validation.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "var\n  hydra = require('./lib/core'),\n  utils = require('./lib/utils');\n\n\nrequire('./lib/http-client');\nrequire('./lib/model');\nrequire('./lib/validation');\n\n\nhydra.loadApi = function (url) {\n  return hydra.httpClient.request('GET', url)\n    .then(function (response) {\n      return hydra.api(response.body, url);\n    })\n    .then(function (api) {\n      api.iri = url;\n\n      return api;\n    });\n};\n\n\nhydra.documentFromResponse = function (response) {\n  return hydra.httpClient.apiLink(response.headers, response.request.url)\n    .then(function (apiUrl) {\n      return hydra.loadApi(apiUrl);\n    })\n    .then(function (api) {\n      return hydra.document(api, response.body, response.request.url);\n    })\n    .then(function (document) {\n      return hydra.httpClient.contentLocation(response.headers, response.request.url)\n        .then(function (contentLocation) {\n          document.iri = contentLocation || response.request.url;\n\n          return document;\n        });\n    });\n};\n\n\nhydra.loadDocument = function (url) {\n  return hydra.httpClient.request('GET', url)\n    .then(function (response) {\n      return hydra.documentFromResponse(response, url);\n    });\n};\n\n\n// export utils\nhydra.utils = utils;\n\n\n// set defaults\nhydra.defaults = {};\nhydra.defaults.invokeOperation = hydra.httpClient.jsonLdInvoke;\nhydra.defaults.validateClass = hydra.simpleValidateClass;\nhydra.defaults.model = {};\nhydra.defaults.model.createInvoke = hydra.model.createHttpJsonLdInvoke;\nhydra.defaults.model.invokeOperation = hydra.httpClient.rawJsonLdInvoke;\n\n\nmodule.exports = hydra;\n",
    "var\n  utils = require('./utils'),\n  _ = utils.require('lodash'),\n  jsonldp = utils.require('jsonld').promises();\n\n\nvar hydra = {};\n\n\nhydra.ns = {\n  vocab: 'http://www.w3.org/ns/hydra/core#',\n  apiDocumentation: 'http://www.w3.org/ns/hydra/core#apiDocumentation',\n  member: 'http://www.w3.org/ns/hydra/core#member'\n};\n\n\nvar rdfs = {\n  ns: {\n    comment: 'http://www.w3.org/2000/01/rdf-schema#comment',\n    label: 'http://www.w3.org/2000/01/rdf-schema#label',\n    range: 'http://www.w3.org/2000/01/rdf-schema#range'\n  }\n};\n\n\nhydra.Api = function (def) {\n  var self = this;\n\n  this.iri = utils.iri(def);\n\n  this.init = function () {\n    var classFrameDef = {\n      '@context': {\n        '@vocab': hydra.ns.vocab,\n        'label': rdfs.ns.label\n      },\n      '@type': 'Class'\n    };\n\n    var operationFrameDef = {\n      '@context': {\n        '@vocab': hydra.ns.vocab,\n        'label': rdfs.ns.label\n      },\n      '@type': 'Operation'\n    };\n\n    return Promise.all([\n      jsonldp.frame(def, classFrameDef)\n        .then(function (classDef) {\n          self.classDef = classDef;\n        }),\n      jsonldp.frame(def, operationFrameDef)\n        .then(function (operationDef) {\n          self.operationDef = operationDef;\n        })])\n      .then(function () {\n        var inits = [];\n\n        self.classes = self.classDef['@graph'].map(function (def) {\n          var instance = new hydra.Class(self, def);\n\n          inits.push(instance.init());\n\n          return instance;\n        });\n\n        self.findClass = _.find.bind(null, self.classes, 'iri');\n\n        self.operations = self.operationDef['@graph'].map(function (def) {\n          var instance = new hydra.Operation(self, def);\n\n          inits.push(instance.init());\n\n          return instance;\n        });\n\n        self.findOperation = _.find.bind(null, self.operations, 'iri');\n\n        return Promise.all(inits)\n          .then(function () {\n            return self;\n          });\n      });\n  };\n};\n\n\nhydra.Document = function (api, def, iri) {\n  var self = this;\n\n  this.api = api;\n  this.iri = iri || utils.iri(def);\n\n  this.init = function () {\n    return Promise.resolve()\n      .then(function () {\n        def = utils.unwrap(def);\n\n        if (!('@type' in def)) {\n          return Promise.reject('type missing');\n        }\n\n        self.classes = _.values(def['@type'])\n          .filter(function (type) {\n            return !!self.api.findClass(type);\n          })\n          .map(function (type) {\n            return new hydra.ClassDocument(self, self.api.findClass(type), def);\n          });\n\n        self.properties = self.classes\n          .map(function (documentClass) {\n            return documentClass.abstract.properties\n              .filter(function (abstractProperty) {\n                return abstractProperty.iri in def;\n              })\n              .map(function (abstractProperty) {\n                return new hydra.PropertyDocument(self, abstractProperty, def[abstractProperty.iri]);\n              });\n          })\n          .reduce(function (properties, classProperties) {\n            return properties.concat(classProperties);\n          }, []);\n\n        self.findProperty = _.find.bind(null, self.properties, 'iri');\n\n        self.findOperation = function() {\n          if (arguments.length === 1) {\n            var method = arguments[0];\n\n            return self.classes\n              .map(function (documentClass) {\n                return documentClass.findOperation(method);\n              })\n              .shift();\n          } else {\n            var iri = arguments[0];\n            var method = arguments[1];\n\n            var documentProperty = self.findProperty(iri);\n\n            if (!documentProperty) {\n              return undefined;\n            }\n\n            return documentProperty.findOperation(method);\n          }\n        };\n\n        return self;\n      });\n  };\n};\n\n\nhydra.Class = function (api, def) {\n  var self = this;\n\n  this.api = api;\n  this.iri = def['@id'];\n  this.label = def.label;\n\n  this.init = function () {\n    return Promise.resolve().then(function () {\n      self.operations = utils.toArray(def.supportedOperation).map(function (operationDef) {\n        return self.api.findOperation(operationDef['@id']);\n      });\n\n      self.findOperation = _.find.bind(null, self.operations, 'method');\n\n      self.properties = utils.toArray(def.supportedProperty).map(function (propertyDef) {\n        return new hydra.Property(self.api, propertyDef);\n      });\n\n      self.findProperty = _.find.bind(null, self.properties, 'iri');\n\n      return self;\n    });\n  };\n\n  this.validate = hydra.defaults.validateClass;\n};\n\n\nhydra.ClassDocument = function (document, abstract, def) {\n  this.document = document;\n  this.iri = abstract.iri;\n  this.abstract = abstract;\n  this.label = this.abstract.label;\n  this.operations = abstract.operations.map(function (operation) {\n    return new hydra.OperationDocument(document, operation);\n  });\n  this.properties = abstract.properties\n    .filter(function (property) {\n      return property.iri in def;\n    })\n    .map(function (property) {\n      return new hydra.PropertyDocument(document, property, def[property.iri]);\n    });\n\n  this.findOperation = _.find.bind(null, this.operations, 'method');\n\n  this.findProperty = _.find.bind(null, this.properties, 'iri');\n};\n\n\nhydra.Operation = function (api, def) {\n  var self = this;\n\n  this.api = api;\n  this.iri = def['@id'];\n  this.label = def.label;\n\n  this.init = function () {\n    return Promise.resolve().then(function () {\n      self.method = def.method;\n      self.statusCodes = def.statusCodes;\n      self.expects = self.api.findClass(def.expects);\n      self.returns = self.api.findClass(def.returns);\n\n      return self;\n    });\n  };\n};\n\n\nhydra.OperationDocument = function (document, abstract, def) {\n  this.document = document;\n  this.iri = abstract.iri;\n  this.abstract = abstract;\n  this.link = !!def ? utils.iri(def) : null;\n  this.label = this.abstract.label;\n  this.method = this.abstract.method;\n  this.statusCodes = this.abstract.statusCodes;\n  this.expects = this.abstract.expects;\n  this.returns = this.abstract.returns;\n  this.invoke = hydra.defaults.invokeOperation.bind(this);\n};\n\n\nhydra.Property = function (api, def) {\n  var self = this;\n\n  this.api = api;\n  this.iri = utils.iri(def.property);\n  this.title = def.title;\n  this.description = def.description;\n  this.label = def.label;\n  this.readonly = def.readonly;\n  this.writeonly = def.writeonly;\n  this.operations = utils.toArray(def.property.supportedOperation)\n    .map(function (operationDef) {\n      return self.api.findOperation(utils.iri(operationDef));\n    });\n\n  this.findOperation = _.find.bind(null, this.operations, 'method');\n};\n\n\nhydra.PropertyDocument = function (document, abstract, def) {\n  this.document = document;\n  this.iri = abstract.iri;\n  this.abstract = abstract;\n  this.link = !!def ? utils.iri(def) : null;\n  this.label = this.abstract.label;\n  this.operations = abstract.operations.map(function (operation) {\n    return new hydra.OperationDocument(document, operation, def);\n  });\n\n  this.findOperation = _.find.bind(null, this.operations, 'method');\n};\n\n\nhydra.api = function (json, base) {\n  if (_.isString(json)) {\n    json = JSON.parse(json);\n  }\n\n  return jsonldp.expand(json, {base: base})\n    .then(function (compact) {\n      return (new hydra.Api(compact)).init();\n    });\n};\n\n\nhydra.document = function (api, json, base) {\n  if (_.isString(json)) {\n    json = JSON.parse(json);\n  }\n\n  return jsonldp.expand(json, {base: base})\n    .then(function (compact) {\n      return (new hydra.Document(api, compact, base)).init();\n    });\n};\n\n\nmodule.exports = hydra;",
    "var\n  hydra = require('./core'),\n  utils = require('./utils'),\n  jsonld = utils.require('jsonld'),\n  jsonldp = utils.require('jsonld').promises();\n\n\nhydra.httpClient = {};\n\n\nif (typeof XMLHttpRequest !== 'undefined') {\n  /**\n   * Converts a string to a UTF-8 encoded string\n   * @param string The string to encode\n   * @returns {string} The UTF-8 string\n   */\n  hydra.httpClient.utf8Encode = function (string) {\n    string = string.replace(/\\r\\n/g, '\\n');\n\n    var utftext = '';\n\n    for (var n = 0; n < string.length; n++) {\n      var c = string.charCodeAt(n);\n\n      if (c < 128) {\n        utftext += String.fromCharCode(c);\n      } else if ((c > 127) && (c < 2048)) {\n        utftext += String.fromCharCode((c >> 6) | 192);\n        utftext += String.fromCharCode((c & 63) | 128);\n      } else {\n        utftext += String.fromCharCode((c >> 12) | 224);\n        utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n        utftext += String.fromCharCode((c & 63) | 128);\n      }\n    }\n\n    return utftext;\n  };\n\n  /**\n   * Converts a string to a base-64 encoded string\n   * @param input The string to encode\n   * @returns {string} The base-64 string\n   */\n  hydra.httpClient.base64Encode = function (input) {\n    var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var output = '';\n    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n    var i = 0;\n\n    input = hydra.httpClient.utf8Encode(input);\n\n    while (i < input.length) {\n      chr1 = input.charCodeAt(i++);\n      chr2 = input.charCodeAt(i++);\n      chr3 = input.charCodeAt(i++);\n\n      enc1 = chr1 >> 2;\n      enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n      enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n      enc4 = chr3 & 63;\n\n      if (isNaN(chr2)) {\n        enc3 = enc4 = 64;\n      } else if (isNaN(chr3)) {\n        enc4 = 64;\n      }\n\n      output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);\n    }\n\n    return output;\n  };\n\n  /**\n   * Request implementation using XMLHttpRequest interface\n   *\n   * @param method HTTP method\n   * @param url URL\n   * @param headers Header key/value pairs\n   * @param content Content\n   * @param callback Callback function using with interface: statusCode, headers, content, error\n   */\n  hydra.httpClient.requestAsync = function (method, url, headers, content, callback, options) {\n    options = options || {};\n\n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = function () {\n      if (xhr.readyState === xhr.DONE) {\n        var\n          headerLines = xhr.getAllResponseHeaders().split('\\r\\n'),\n          resHeaders = {};\n\n        for (var i = 0; i < headerLines.length; i++) {\n          var headerLine = headerLines[i].split(': ', 2);\n          resHeaders[headerLine[0].toLowerCase()] = headerLine[1];\n        }\n\n        callback(xhr.status, resHeaders, xhr.responseText);\n      }\n    };\n\n    xhr.open(method, url, true);\n\n    for (var header in headers) {\n      xhr.setRequestHeader(header, headers[header]);\n    }\n\n    if (options.user && options.password) {\n      xhr.setRequestHeader(\"Authorization\", \"Basic \" + hydra.httpClient.base64Encode(options.user + \":\" + options.password));\n    }\n\n    xhr.send(content);\n  };\n} else {\n  /**\n   * Request implementation using the npm request module\n   *\n   * @param method HTTP method\n   * @param url URL\n   * @param headers Header key/value pairs\n   * @param content Content\n   * @param callback Callback function using with interface: statusCode, headers, content, error\n   * @param options Additional options like user or password\n   */\n  hydra.httpClient.requestAsync = function (method, url, headers, content, callback, options) {\n    var request = require('request');\n\n    options = options || {};\n\n    var req = {\n      method: method,\n      url: url,\n      headers: headers,\n      body: content\n    };\n\n    if (options.user && options.password) {\n      req.auth = {\n        user: options.user,\n        password: options.password\n      };\n    }\n\n    request(req, function (error, res, body) {\n      if (error) {\n        callback(null, null, null, error);\n      } else {\n        callback(res.statusCode, res.headers, body);\n      }\n    });\n  };\n}\n\n/**\n * Promise request implementation\n *\n * @param method HTTP method\n * @param url URL\n * @param headers Header key/value pairs\n * @param content Content\n * @param options Additional options like user or password\n * @returns {Promise}\n */\nhydra.httpClient.request = function (method, url, headers, content, options) {\n  return new Promise(function (resolve, reject) {\n    hydra.httpClient.requestAsync(method, url, headers, content, function (status, resHeaders, resBody, error) {\n      var response = {\n        status: status,\n        headers: resHeaders,\n        body: resBody,\n        request: {\n          url: url,\n          method: method,\n          headers: headers,\n          body: content\n        }\n      };\n\n      if (error) {\n        reject(error);\n      } else if (status >= 400) {\n        reject(new Error('status code ' + status + ': ' + resBody));\n      } else {\n        resolve(response);\n      }\n    }, options);\n  });\n};\n\n/**\n * Extracts the Hydra API Documentation value of the Link header field\n *\n * @param headers\n * @param base\n * @returns {Promise}\n */\nhydra.httpClient.apiLink = function (headers, base) {\n  if (!('link' in headers)) {\n    return Promise.resolve(undefined);\n  }\n\n  var rels = jsonld.parseLinkHeader(headers.link);\n\n  if (!(hydra.ns.apiDocumentation in rels)) {\n    return Promise.resolve(undefined);\n  }\n\n  return utils.expandIri(rels[hydra.ns.apiDocumentation].target, base);\n};\n\n/**\n * Extracts the value of the Content-Location header field\n *\n * @param headers\n * @param base\n * @returns {*}\n */\nhydra.httpClient.contentLocation = function (headers, base) {\n  if (!('content-location' in headers)) {\n    return Promise.resolve(undefined);\n  }\n\n  return utils.expandIri(headers['content-location'], base);\n};\n\n/**\n * Calls an operations with the given headers and content\n *\n * @param headers\n * @param content\n * @param options\n * @returns {Promise}\n */\nhydra.httpClient.rawInvoke = function (headers, content, options) {\n  var self = this;\n\n  var url = self.link || self.document.iri;\n\n  return hydra.httpClient.request(self.method, url, headers, content, options);\n};\n\n/**\n * Calls an operations with the JSON-LD content and converts the response body to JSON-LD\n *\n * @param content\n * @param options\n * @returns {Promise}\n */\nhydra.httpClient.rawJsonLdInvoke = function (content, options) {\n  var self = this;\n\n  var headers = {\n    'Accept': 'application/ld+json'\n  };\n\n  if (self.method === 'PATCH' || self.method === 'POST' || self.method === 'PUT') {\n    headers['Content-Type'] = 'application/ld+json';\n  }\n\n  return hydra.httpClient.rawInvoke.bind(self)(headers, JSON.stringify(content), options)\n    .then(function (response) {\n      if (response.body && response.body.trim() !== '') {\n        return jsonldp.expand(JSON.parse(response.body), {base: response.request.url})\n          .then(function (expandedBody) {\n            response.body = expandedBody;\n\n            return response;\n          })\n      } else {\n        response.body = null;\n\n        return response;\n      }\n    });\n};\n\n/**\n * Calls an operations with the JSON-LD content and returns the response body converted to JSON-LD\n *\n * @param content\n * @param options\n * @returns {Promise}\n */\nhydra.httpClient.jsonLdInvoke = function (content, options) {\n  var self = this;\n\n  return hydra.httpClient.rawJsonLdInvoke.bind(self)(content, options)\n    .then(function (response) {\n      return response.body;\n    });\n};\n",
    "var\n  hydra = require('./core'),\n  utils = require('./utils'),\n  _ = utils.require('lodash'),\n  jsonldp = utils.require('jsonld').promises();\n\n\nhydra.model = {};\n\n\n/**\n * Creates an invoke function for model objects that compacts the response using the given context\n *\n * @param operation\n * @returns {Function}\n */\nhydra.model.createHttpJsonLdInvoke = function (operation) {\n  return function (input, options) {\n    options = options || {};\n\n    var context = {};\n\n    if ('@context' in this) {\n      context = this['@context'];\n    }\n\n    context = options.context || context;\n\n    if (input && input.toJSON) {\n      input = input.toJSON();\n    }\n\n    return hydra.httpClient.rawJsonLdInvoke.call(operation, input, options)\n      .then(function (response) {\n        if (!response.body) {\n          return Promise.resolve(null);\n        }\n\n        return hydra.documentFromResponse(response)\n          .then(function (document) {\n            return jsonldp.compact(response.body, context)\n              .then(function (output) {\n                return hydra.model.create(document.classes, output);\n              });\n          });\n      });\n  };\n};\n\n/**\n * Converts a model object to serializable object without functions and property flagged with @omit\n */\nhydra.model.toJSON = function () {\n  var copyProperties = function (object, root) {\n    if (!object) {\n      return null;\n    }\n\n    var copy = _.keys(object).reduce(function (json, key) {\n      var value = object[key];\n\n      // don't add function properties\n      if (_.isFunction(value)) {\n        return json;\n      }\n\n      // don't add properties with @omit flag\n      if (_.isObject(value) && '@omit' in value && value['@omit']) {\n        return json;\n      }\n\n      if (_.isObject(value)) {\n        // copy sub properties\n        json[key] = copyProperties(value, root);\n      } else {\n        // copy string values\n        json[key] = value;\n      }\n\n      return json;\n    }, {});\n\n    // convert to Array if original object was an Array\n    if (_.isArray(object)) {\n      copy = _.values(object);\n    }\n\n    return copy;\n  };\n\n  return copyProperties(this);\n};\n\n/**\n * Adds a @omit property to an object to hide it from serialization\n *\n * @param property\n * @returns {Object}\n */\nhydra.model.hide = function (property) {\n  property['@omit'] = true;\n\n  return property;\n};\n\n/**\n * Creates a model object based on one or more classes\n *\n * @param classes The class or classes the model will be bases on\n * @param properties Properties to merge into the model object\n * @param options Additional options to control the model creation\n * @returns {*}\n */\nhydra.model.create = function (classes, properties, options) {\n  var processOperations = function (root, operations) {\n    operations.forEach(function (operation) {\n      var key = '@' + operation.method.toLowerCase();\n\n      if (!(key in root)) {\n        root[key] = options.createInvoke(operation).bind(model);\n      }\n    });\n\n    return Promise.resolve();\n  };\n\n  var processProperties = function (root, properties) {\n    return Promise.all(properties.map(function (property) {\n      return utils.compactIri(property.iri, model['@context'])\n        .then(function (key) {\n          if (!(key in root)) {\n            root[key] = {};\n          }\n\n          return processOperations(root[key], property.operations);\n        });\n    }));\n  };\n\n  var processClass = function (apiClass) {\n    model['@type'].push(apiClass.iri);\n\n    return processOperations(model, apiClass.operations)\n      .then(function () {\n        return processProperties(model, apiClass.properties);\n      });\n  };\n\n  classes = utils.toArray(classes);\n\n  options = options || {};\n  options.createInvoke = options.createInvoke || hydra.defaults.model.createInvoke;\n\n  var model = _.clone(properties);\n\n  _.defaults(model, {\n    '@context': {},\n    toJSON: hydra.model.toJSON\n  });\n\n  model['@type'] = [];\n  model.api = classes[0].api || classes[0].abstract.api;\n  model.api['@omit'] = true;\n\n  if (classes[0].document) {\n    model.document = classes[0].document;\n    model.document['@omit'] = true;\n  }\n\n  return Promise.all(classes.map(function (apiClass) {\n    return processClass(apiClass);\n  })).then(function () {\n    return model;\n  });\n};\n\n/**\n * Creates a model object based on a GET request to the given URL\n *\n * @param url URL\n * @param properties Properties that will be merged into the model object\n * @param options Options for the request\n * @returns {Promise}\n */\nhydra.model.load = function (url, properties, options) {\n  return hydra.loadDocument(url)\n    .then(function (document) {\n      return hydra.model.create(document.classes, properties, options);\n    });\n};\n",
    "var utils = {};\n\n\nutils.require = function (module) {\n  var globalModule = module;\n\n  if (globalModule === 'lodash') {\n    globalModule = '_';\n  }\n\n  if (typeof window !== 'undefined' && globalModule in window) {\n    return window[globalModule];\n  }\n\n  return require(module);\n};\n\n\nvar\n  _ = utils.require('lodash'),\n  jsonldp = utils.require('jsonld').promises();\n\n\n/**\n * Creates a Hydra Collection from a map or array of members\n *\n * @param iri\n * @param members\n * @returns {Collection}\n */\nutils.collection = function (iri, members) {\n  return {\n    '@id': iri,\n    '@type': 'http://www.w3.org/ns/hydra/core#Collection',\n    'http://www.w3.org/ns/hydra/core#member': _.values(members).map(function (member) {\n      return {\n        '@id': member['@id'],\n        '@type': member['@type']\n      };\n    })\n  };\n};\n\n/**\n * Uses the given context to create a short form of the IRI\n *\n * @param iri\n * @param context\n * @returns {Promise}\n */\nutils.compactIri = function (iri, context) {\n  var dummy = {};\n\n  dummy[iri] = '';\n\n  return jsonldp.compact(dummy, context)\n    .then(function (compactDummy) {\n      return _.keys(compactDummy).pop();\n    });\n};\n\n/**\n * Creates a long version of the IRI using the given base\n *\n * @param iri\n * @param base\n * @returns {Promise}\n */\nutils.expandIri = function (iri, base) {\n  if (!base) {\n    return Promise.resolve(iri);\n  }\n\n  var dummy = {\n    '@context': {\n      '@base': base,\n      '@vocab': 'http://schema.org/'\n    },\n    'name': {\n      '@id': iri\n    }\n  };\n\n  return jsonldp.expand(dummy)\n    .then(function (expanded) {\n      return expanded[0]['http://schema.org/name'][0]['@id'];\n    });\n};\n\n/**\n * Extracts the IRI of an JSON-LD object\n *\n * @param obj\n * @returns {*}\n */\nutils.iri = function (obj) {\n  obj = utils.unwrap(obj);\n\n  if (!obj) {\n    return undefined;\n  }\n\n  if (_.isString(obj)) {\n    return obj;\n  }\n\n  if (!('@id' in obj)) {\n    return undefined;\n  }\n\n  return obj['@id'];\n};\n\n/**\n * Checks if the given object is a Hydra Collection\n *\n * @param collection\n * @returns {boolean}\n */\nutils.isCollection = function (collection) {\n  if (_.isObject(collection)) {\n    return false;\n  }\n\n  if (!collection.member && !(ns.member in collection)) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Converts single objects and Hydra Collections to Arrays and forwards existing Arrays\n *\n * @param obj\n * @returns {Array}\n */\nutils.toArray = function (obj) {\n  if (!obj) {\n    return [];\n  }\n\n  if (utils.isCollection(obj)) {\n    obj = obj.member;\n  }\n\n  if (!_.isArray(obj)) {\n    return [obj];\n  }\n\n  return obj;\n};\n\n/**\n * Extracts the first subject of an JSON-Ld object\n *\n * @param obj\n * @returns {*}\n */\nutils.unwrap = function (obj) {\n  if (!obj) {\n    return undefined;\n  }\n\n  if (_.isString(obj)) {\n    return obj;\n  }\n\n  if ('@graph' in obj) {\n    obj = obj['@graph'];\n  }\n\n  if (_.isArray(obj)) {\n    if (obj.length === 0) {\n      return undefined;\n    } else {\n      obj = obj[0];\n    }\n  }\n\n  return obj;\n};\n\n\nmodule.exports = utils;",
    "var\n  hydra = require('./core'),\n  utils = require('./utils'),\n  jsonldp = utils.require('jsonld').promises();\n\n\nhydra.simpleValidateClass = function (object, read, write) {\n  var self = this;\n\n  if (!object) {\n    return Promise.resolve();\n  }\n\n  return jsonldp.expand(object)\n    .then(function (expanded) {\n      if (expanded.length > 1) {\n        return Promise.reject(new Error('object contains multiple subjects'));\n      }\n\n      expanded = expanded.shift();\n\n      if (!('@type' in expanded)) {\n        return Promise.reject(new Error('@type missing'));\n      }\n\n      if (utils.toArray(expanded['@type']).indexOf(self.iri) < 0) {\n        return Promise.reject(new Error('expected class <' + self.iri + '>'));\n      }\n\n      var error = self.properties\n        .map(function (property) {\n          if (property.readonly && property.iri in object) {\n            return new Error('readonly property <' + property.iri + '> filled with value \"' + object[property.iri] + '\"');\n          }\n\n          return false;\n        })\n        .filter(function (error) {\n          return !!error;\n        })\n        .shift();\n\n      if (error) {\n        return Promise.reject(error);\n      }\n\n      return Promise.resolve();\n    });\n};\n\n"
  ]
}